@args com.linkedin.pegasus.generator.spec.UnionTemplateSpec union, org.coursera.courier.tslite.TSSyntax syntax
@import org.coursera.courier.tslite.TSSyntax.EscapeOptions
@import com.linkedin.pegasus.generator.spec.UnionTemplateSpec.Member
@import org.coursera.courier.schema.TypedDefinitions

@{ String className = syntax.escapeKeyword(union.getClassName(), EscapeOptions.MANGLE) }

@for(String theImport : syntax.imports(union)) {
  @theImport;
}

@if (union.getTyperefClass() != null) {
  @classAnnotations(union.getTyperefClass().getSchema())
}

export type @className = @if (!union.getMembers().isEmpty()) @for(Member member: union.getMembers()) { @(className).@syntax.toUnionMemberName(member) @if (!member_isLast) { |} } } else { void};

@if(!union.getMembers().isEmpty()) {
export module @className {
  export interface @(className)Member {
    [key: string]: @for(Member member: union.getMembers()){ @syntax.toTypeString(member, false) @if(!member_isLast){ |}};
  }
  @for(Member member: union.getMembers()) {
    @{ String unionMemberInterfaceName = syntax.toUnionMemberName(member) }
    @{ String unionLookupString = syntax.toTypeString(member.getClassTemplateSpec(), true) }
    @{ String memberClassName = syntax.toTypeString(member, false) }
    export interface @unionMemberInterfaceName extends @(className)Member {
      "@unionLookupString": @memberClassName;
    }
  }

  export function unpack(union: @className) {
    return {
      @for(Member member: union.getMembers()) {
        @(syntax.filterForUnionGetterKey(syntax.toTypeString(member, false))): union["@syntax.toTypeString(member.getClassTemplateSpec(), true)"] as @syntax.toTypeString(member, false) @if(!member_isLast) {,}
      }
    };
  }
}
}
