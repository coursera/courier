import { WithoutNamespace } from "../tslite-bindings/.WithoutNamespace";
import { Map } from "../tslite-bindings/CourierRuntime";
import { WithCustomArrayTestId } from "../tslite-bindings/org.coursera.arrays.WithCustomArrayTestId";
import { WithCustomTypesArray } from "../tslite-bindings/org.coursera.arrays.WithCustomTypesArray";
import { WithCustomTypesArrayUnion } from "../tslite-bindings/org.coursera.arrays.WithCustomTypesArrayUnion";
import { WithPrimitivesArray } from "../tslite-bindings/org.coursera.arrays.WithPrimitivesArray";
import { WithRecordArray } from "../tslite-bindings/org.coursera.arrays.WithRecordArray";
import { BooleanId } from "../tslite-bindings/org.coursera.customtypes.BooleanId";
import { BoxedIntId } from "../tslite-bindings/org.coursera.customtypes.BoxedIntId";
import { ByteId } from "../tslite-bindings/org.coursera.customtypes.ByteId";
import { CaseClassCustomIntWrapper } from "../tslite-bindings/org.coursera.customtypes.CaseClassCustomIntWrapper";
import { CaseClassStringIdWrapper } from "../tslite-bindings/org.coursera.customtypes.CaseClassStringIdWrapper";
import { CharId } from "../tslite-bindings/org.coursera.customtypes.CharId";
import { CustomArrayTestId } from "../tslite-bindings/org.coursera.customtypes.CustomArrayTestId";
import { CustomInt } from "../tslite-bindings/org.coursera.customtypes.CustomInt";
import { CustomIntWrapper } from "../tslite-bindings/org.coursera.customtypes.CustomIntWrapper";
import { CustomMapTestKeyId } from "../tslite-bindings/org.coursera.customtypes.CustomMapTestKeyId";
import { CustomMapTestValueId } from "../tslite-bindings/org.coursera.customtypes.CustomMapTestValueId";
import { CustomRecord } from "../tslite-bindings/org.coursera.customtypes.CustomRecord";
import { CustomRecordTestId } from "../tslite-bindings/org.coursera.customtypes.CustomRecordTestId";
import { CustomUnionTestId } from "../tslite-bindings/org.coursera.customtypes.CustomUnionTestId";
import { DateTime } from "../tslite-bindings/org.coursera.customtypes.DateTime";
import { DoubleId } from "../tslite-bindings/org.coursera.customtypes.DoubleId";
import { FloatId } from "../tslite-bindings/org.coursera.customtypes.FloatId";
import { IntId } from "../tslite-bindings/org.coursera.customtypes.IntId";
import { LongId } from "../tslite-bindings/org.coursera.customtypes.LongId";
import { ShortId } from "../tslite-bindings/org.coursera.customtypes.ShortId";
import { StringId } from "../tslite-bindings/org.coursera.customtypes.StringId";
import { DeprecatedRecord } from "../tslite-bindings/org.coursera.deprecated.DeprecatedRecord";
import { EmptyEnum } from "../tslite-bindings/org.coursera.enums.EmptyEnum";
import { EnumProperties } from "../tslite-bindings/org.coursera.enums.EnumProperties";
import { Fruits } from "../tslite-bindings/org.coursera.enums.Fruits";
import { DefaultLiteralEscaping } from "../tslite-bindings/org.coursera.escaping.DefaultLiteralEscaping";
import { KeywordEscaping } from "../tslite-bindings/org.coursera.escaping.KeywordEscaping";
import { ReservedClassFieldEscaping } from "../tslite-bindings/org.coursera.escaping.ReservedClassFieldEscaping";
import { class$ } from "../tslite-bindings/org.coursera.escaping.class";
import { WithFixed8 } from "../tslite-bindings/org.coursera.fixed.WithFixed8";
import { Toggle } from "../tslite-bindings/org.coursera.maps.Toggle";
import { WithComplexTypesMap } from "../tslite-bindings/org.coursera.maps.WithComplexTypesMap";
import { WithComplexTypesMapUnion } from "../tslite-bindings/org.coursera.maps.WithComplexTypesMapUnion";
import { WithCustomMapTestIds } from "../tslite-bindings/org.coursera.maps.WithCustomMapTestIds";
import { WithCustomTypesMap } from "../tslite-bindings/org.coursera.maps.WithCustomTypesMap";
import { WithPrimitivesMap } from "../tslite-bindings/org.coursera.maps.WithPrimitivesMap";
import { WithTypedKeyMap } from "../tslite-bindings/org.coursera.maps.WithTypedKeyMap";
import { CourierFile } from "../tslite-bindings/org.coursera.records.CourierFile";
import { JsonTest } from "../tslite-bindings/org.coursera.records.JsonTest";
import { Message } from "../tslite-bindings/org.coursera.records.Message";
import { WithAnonymousUnionArray } from "../tslite-bindings/org.coursera.arrays.WithAnonymousUnionArray";
import { Note } from "../tslite-bindings/org.coursera.records.Note";
import { WithDateTime } from "../tslite-bindings/org.coursera.records.WithDateTime";
import { WithFlatTypedDefinition } from "../tslite-bindings/org.coursera.records.WithFlatTypedDefinition";
import { WithInclude } from "../tslite-bindings/org.coursera.records.WithInclude";
import { WithTypedDefinition } from "../tslite-bindings/org.coursera.records.WithTypedDefinition";
import { WithUnion } from "../tslite-bindings/org.coursera.records.WithUnion";
import { Fixed8 } from "../tslite-bindings/org.coursera.fixed.Fixed8";
import { class$ as EscapedClassRecord} from "../tslite-bindings/org.coursera.records.class";
import { Simple } from "../tslite-bindings/org.coursera.records.primitivestyle.Simple";
import { WithComplexTypes } from "../tslite-bindings/org.coursera.records.primitivestyle.WithComplexTypes";
import { WithPrimitives } from "../tslite-bindings/org.coursera.records.primitivestyle.WithPrimitives";
import { BooleanTyperef } from "../tslite-bindings/org.coursera.records.test.BooleanTyperef";
import { BytesTyperef } from "../tslite-bindings/org.coursera.records.test.BytesTyperef";
import { DoubleTyperef } from "../tslite-bindings/org.coursera.records.test.DoubleTyperef";
import { Empty } from "../tslite-bindings/org.coursera.records.test.Empty";
import { FloatTyperef } from "../tslite-bindings/org.coursera.records.test.FloatTyperef";
import { InlineOptionalRecord } from "../tslite-bindings/org.coursera.records.test.InlineOptionalRecord";
import { InlineRecord } from "../tslite-bindings/org.coursera.records.test.InlineRecord";
import { IntCustomType as TestIntCustomType } from "../tslite-bindings/org.coursera.records.test.IntCustomType";
import { IntTyperef as TestIntTyperef } from "../tslite-bindings/org.coursera.records.test.IntTyperef";
import { LongTyperef } from "../tslite-bindings/org.coursera.records.test.LongTyperef";
import { Message as TestMessage } from "../tslite-bindings/org.coursera.records.test.Message";
import { NumericDefaults } from "../tslite-bindings/org.coursera.records.test.NumericDefaults";
import { OptionalBooleanTyperef } from "../tslite-bindings/org.coursera.records.test.OptionalBooleanTyperef";
import { OptionalBytesTyperef } from "../tslite-bindings/org.coursera.records.test.OptionalBytesTyperef";
import { OptionalDoubleTyperef } from "../tslite-bindings/org.coursera.records.test.OptionalDoubleTyperef";
import { OptionalFloatTyperef } from "../tslite-bindings/org.coursera.records.test.OptionalFloatTyperef";
import { OptionalIntCustomType } from "../tslite-bindings/org.coursera.records.test.OptionalIntCustomType";
import { OptionalIntTyperef } from "../tslite-bindings/org.coursera.records.test.OptionalIntTyperef";
import { OptionalLongTyperef } from "../tslite-bindings/org.coursera.records.test.OptionalLongTyperef";
import { OptionalStringTyperef } from "../tslite-bindings/org.coursera.records.test.OptionalStringTyperef";
import { RecursivelyDefinedRecord } from "../tslite-bindings/org.coursera.records.test.RecursivelyDefinedRecord";
import { Simple as TestSimple } from "../tslite-bindings/org.coursera.records.test.Simple";
import { StringTyperef } from "../tslite-bindings/org.coursera.records.test.StringTyperef";
import { With22Fields } from "../tslite-bindings/org.coursera.records.test.With22Fields";
import { With23Fields } from "../tslite-bindings/org.coursera.records.test.With23Fields";
import { WithCaseClassCustomType } from "../tslite-bindings/org.coursera.records.test.WithCaseClassCustomType";
import { WithComplexTypeDefaults } from "../tslite-bindings/org.coursera.records.test.WithComplexTypeDefaults";
import { WithComplexTyperefs } from "../tslite-bindings/org.coursera.records.test.WithComplexTyperefs";
import { WithComplexTypes as TestWithComplexTypes } from "../tslite-bindings/org.coursera.records.test.WithComplexTypes";
import { WithCourierFile } from "../tslite-bindings/org.coursera.records.test.WithCourierFile";
import { WithCustomIntWrapper } from "../tslite-bindings/org.coursera.records.test.WithCustomIntWrapper";
import { WithCustomRecord } from "../tslite-bindings/org.coursera.records.test.WithCustomRecord";
import { WithCustomRecordTestId } from "../tslite-bindings/org.coursera.records.test.WithCustomRecordTestId";
import { WithDateTime as TestWithDateTime } from "../tslite-bindings/org.coursera.records.test.WithDateTime";
import { WithInclude as TestWithInclude } from "../tslite-bindings/org.coursera.records.test.WithInclude";
import { WithInlineRecord } from "../tslite-bindings/org.coursera.records.test.WithInlineRecord";
import { WithOmitField } from "../tslite-bindings/org.coursera.records.test.WithOmitField";
import { WithOptionalComplexTypeDefaults } from "../tslite-bindings/org.coursera.records.test.WithOptionalComplexTypeDefaults";
import { WithOptionalComplexTypes } from "../tslite-bindings/org.coursera.records.test.WithOptionalComplexTypes";
import { WithOptionalComplexTypesDefaultNone } from "../tslite-bindings/org.coursera.records.test.WithOptionalComplexTypesDefaultNone";
import { WithOptionalPrimitiveCustomTypes } from "../tslite-bindings/org.coursera.records.test.WithOptionalPrimitiveCustomTypes";
import { WithOptionalPrimitiveDefaultNone } from "../tslite-bindings/org.coursera.records.test.WithOptionalPrimitiveDefaultNone";
import { WithOptionalPrimitiveDefaults } from "../tslite-bindings/org.coursera.records.test.WithOptionalPrimitiveDefaults";
import { WithOptionalPrimitiveTyperefs } from "../tslite-bindings/org.coursera.records.test.WithOptionalPrimitiveTyperefs";
import { WithOptionalPrimitives } from "../tslite-bindings/org.coursera.records.test.WithOptionalPrimitives";
import { WithPrimitiveCustomTypes } from "../tslite-bindings/org.coursera.records.test.WithPrimitiveCustomTypes";
import { WithPrimitiveDefaults } from "../tslite-bindings/org.coursera.records.test.WithPrimitiveDefaults";
import { WithPrimitiveTyperefs } from "../tslite-bindings/org.coursera.records.test.WithPrimitiveTyperefs";
import { WithPrimitives as TestWithPrimitives } from "../tslite-bindings/org.coursera.records.test.WithPrimitives";
import { WithUnionWithInlineRecord } from "../tslite-bindings/org.coursera.records.test.WithUnionWithInlineRecord";
import { ArrayTyperef } from "../tslite-bindings/org.coursera.typerefs.ArrayTyperef";
import { EnumTyperef } from "../tslite-bindings/org.coursera.typerefs.EnumTyperef";
import { FlatTypedDefinition } from "../tslite-bindings/org.coursera.typerefs.FlatTypedDefinition";
import { InlineRecord as InlineRecordTypeRef } from "../tslite-bindings/org.coursera.typerefs.InlineRecord";
import { InlineRecord2 } from "../tslite-bindings/org.coursera.typerefs.InlineRecord2";
import { IntTyperef } from "../tslite-bindings/org.coursera.typerefs.IntTyperef";
import { MapTyperef } from "../tslite-bindings/org.coursera.typerefs.MapTyperef";
import { RecordTyperef } from "../tslite-bindings/org.coursera.typerefs.RecordTyperef";
import { TypedDefinition } from "../tslite-bindings/org.coursera.typerefs.TypedDefinition";
import { Union } from "../tslite-bindings/org.coursera.typerefs.Union";
import { UnionTyperef } from "../tslite-bindings/org.coursera.typerefs.UnionTyperef";
import { UnionWithInlineRecord } from "../tslite-bindings/org.coursera.typerefs.UnionWithInlineRecord";
import { IntCustomType } from "../tslite-bindings/org.coursera.unions.IntCustomType";
import { IntTyperef as IntTyperefUnion} from "../tslite-bindings/org.coursera.unions.IntTyperef";
import { WithComplexTypesUnion } from "../tslite-bindings/org.coursera.unions.WithComplexTypesUnion";
import { WithCustomUnionTestId } from "../tslite-bindings/org.coursera.unions.WithCustomUnionTestId";
import { WithEmptyUnion } from "../tslite-bindings/org.coursera.unions.WithEmptyUnion";
import { WithPrimitiveCustomTypesUnion } from "../tslite-bindings/org.coursera.unions.WithPrimitiveCustomTypesUnion";
import { WithPrimitiveTyperefsUnion } from "../tslite-bindings/org.coursera.unions.WithPrimitiveTyperefsUnion";
import { WithRecordCustomTypeUnion } from "../tslite-bindings/org.coursera.unions.WithRecordCustomTypeUnion";
import { Fortune } from "../tslite-bindings/org.example.Fortune";
import { FortuneCookie } from "../tslite-bindings/org.example.FortuneCookie";
import { FortuneTelling } from "../tslite-bindings/org.example.FortuneTelling";
import { MagicEightBall } from "../tslite-bindings/org.example.MagicEightBall";
import { MagicEightBallAnswer } from "../tslite-bindings/org.example.MagicEightBallAnswer";
import { TyperefExample } from "../tslite-bindings/org.example.TyperefExample";
import { DateTime as CommonDateTime } from "../tslite-bindings/org.example.common.DateTime";
import { Timestamp } from "../tslite-bindings/org.example.common.Timestamp";
import { DateTime as OtherDateTime } from "../tslite-bindings/org.example.other.DateTime";
import { record } from "../tslite-bindings/org.example.record";
import { WithPrimitivesUnion } from "../tslite-bindings/org.coursera.unions.WithPrimitivesUnion";
import * as ts from "typescript";

import CustomMatcherFactories = jasmine.CustomMatcherFactories;
import CompilerOptions = ts.CompilerOptions;
import TranspileOptions = ts.TranspileOptions;
import Diagnostic = ts.Diagnostic;

// Add a jasmine matcher that will attempt to compile a ts file and report
// any compilation errors
const toCompileMatcher: CustomMatcherFactories = {
  toCompile: (util: any, customEqualityTesters: any) => {
    return {
      compare: (fileName: any, message:any) => {
        const result: any = {};
        var compilerOptions: CompilerOptions = {
          project: "/Users/eboto/code/courier/typescript-lite/testsuite/tsconfig.json",
          diagnostics: true
        };

        const program = ts.createProgram(
          [fileName],
          compilerOptions
        );

        const errors = program.getGlobalDiagnostics()
          .concat(program.getSemanticDiagnostics())
          .concat(program.getDeclarationDiagnostics())
          .concat(program.getSyntacticDiagnostics());
        const errorStr = errors.reduce((accum: any, err: Diagnostic) => {
          const errFile = err.file;
          const msgText = ts.flattenDiagnosticMessageText(err.messageText, "\n");
          const nextAccum = accum + `\n${errFile.path}:${errFile.pos}\n${msgText}\n`;
          return nextAccum;
        }, "");

        result.pass = (errors.length == 0);
        if (!result.pass) {
          result.message = `Compilation expectation failed: ${message} Error was: ${errorStr}`;
        }

        return result;
      }
    };
  }
};

//
// Only test the runtime behavior of Unions
//
describe("Unions", () => {
  it("should compile from correct javascript and unpack", () => {
    const unionOfMessage: WithUnion = {
      "value": {
        "org.coursera.records.Message": {
          "title": "title",
          "body": "Hello, Courier."
        }
      }
    };
    const {note, message} = Union.unpack(unionOfMessage.value);
    expect(note).toBeUndefined();
    expect(message).not.toBeUndefined();
    expect(message.title).toBe("title");
    expect(message.body).toBe("Hello, Courier.");
  });

  it("should access all primitive unions properly", () => {
    const keyShouldNotBeUndefined = (correctUnionKey: string) => (withUnion: WithPrimitivesUnion) => {
      const union = withUnion.union;
      const keys = Object.keys(union);
      keys.forEach((key) => {
        if (key == correctUnionKey) {
          expect(union[key]).not.toBeUndefined(`Expected '${key}' not to be undefined in ${JSON.stringify(union)}`)
        } else {
          expect(union[key]).toBeUndefined(`Expected '${key}' to be defined in ${JSON.stringify(union)}. Only '${correctUnionKey}' was supposed to be defined.`);
        }
      });
    };
    const expectations = [
      [wpu_int, keyShouldNotBeUndefined("int")],
      [wpu_long, keyShouldNotBeUndefined("long")],
      [wpu_float, keyShouldNotBeUndefined("float")],
      [wpu_double, keyShouldNotBeUndefined("double")],
      [wpu_bool, keyShouldNotBeUndefined("boolean")],
      [wpu_string, keyShouldNotBeUndefined("string")],
      [wpu_bytes, keyShouldNotBeUndefined("bytes")]
    ]

    expectations.forEach((expectationData) => {
      const [unionInstance, expectation] = expectationData;
      (expectation as any)(unionInstance);
    });
  });
});

//
// Now attempt to compile our examples from src/compilation-failures. They should all fail.
//
describe("The typescript compiler", () => {
  beforeEach(() => {
    jasmine.addMatchers(toCompileMatcher);
  });

  const expectations = [
    ["should not allow unions with incorrect lookup keys", "union_bad-lookup-string.ts"],
    ["should not allow the body of the union to be malformed", "union_bad-body-content.ts"],
    ["should not allow records to have the wrong field type", "record_wrong-field-type.ts"],
    ["should not allow enums with a bad string value", "enum_bad-string.ts"],
    ["should not allow typerefs with the wrong root type", "typeref_wrong-type.ts"],
    ["should not allow the wrong type as the item of a primitive array", "array_bad-item-type.ts"],
    ["should not allow the wrong type as the item of an enum array", "array_bad-item-type-enum-expected.ts"],
    ["should not allow the wrong type as the value of a map", "map_bad-value-type.ts"]
  ];

  expectations.forEach((expectationPair) => {
    const [testCaseName, fileTest] = expectationPair;
    it(testCaseName, () => {
      expect(`src/compilation-failures/${fileTest}`).not.toCompile("It was expected to fail.");
    })
  });
});

describe("Enums", () => {
  it("Should have successful accessors", () => {
    const fruit1: Fruits = "APPLE";
    expect(fruit1).toEqual(Fruits.APPLE);
    expect(fruit1 == Fruits.APPLE).toBe(true);
  });

  it("Should have nice switch/case semantics", () => {
    const fruit1: Fruits = "APPLE";
    let result: string;
    switch (fruit1) {
      case "APPLE":
        result = "It was an apple";
        break;
      case "PEAR":
        result = "It was a pear";
        break;
      default:
        result = "I don't know what it was.";
    }

    expect(result).toEqual("It was an apple");

    switch (fruit1) {
      case Fruits.APPLE:
        result = "It's still an apple";
        break;
      default:
        result = "Something else."
    }

    expect(result).toEqual("It's still an apple");
  });

  it("Should be enumerated with the .all function", () => {
    expect(Fruits.all).toEqual(["APPLE", "BANANA", "ORANGE", "PINEAPPLE"]);
  });
});


//
// Now just declare a bunch of JSON types (sourced from courier/reference-suite/src/main/json.
//
// Compilation will fail if generation failed in compatibility with these known-good json types.
//
const customint: CustomInt = 1; // typerefs should work

const boolid: BooleanId = true;
const byteid: ByteId = "bytes just a string baby!";
const ref_of_a_ref: CustomIntWrapper = 1;
const fortune_fortuneCookie: Fortune = {
  "telling": {
    "org.example.FortuneCookie": {
      "message": " a message",
      "certainty": 0.1,
      "luckyNumbers": [1, 2, 3]
    }
  },
  "createdAt": "2015-01-01T00:00:00.000Z"
};

const fortune_magicEightBall: Fortune = {
  "telling": {
    "org.example.MagicEightBall": {
      "question": "A question",
      "answer": "IT_IS_CERTAIN"
    }
  },
  "createdAt": "2015-01-01T00:00:00.000Z"
};

const fortuneCookie: FortuneCookie = {
  "message": " a message",
  "certainty": 0.1,
  "luckyNumbers": [1, 2, 3]
};

const fortuneCookie_lackingOptional: FortuneCookie = {
  "message": "a message",
  "luckyNumbers": [1, 2, 3]
};

const kw_escaping: KeywordEscaping = {
  "type" : "test"
};

const msg: Message = {
  "title": "example title",
  "body": "example body"
};

const rcfe: ReservedClassFieldEscaping = {
  "data" : "dataText",
  "schema": "schemaText",
  "copy": "copyText",
  "clone": "cloneText"
};

const simple: Simple = { "message": "simple message" };

const withComplexTypes: TestWithComplexTypes = {
  "record": { "message": "record"},
  "enum": "APPLE",
  "union": { "org.coursera.records.test.Simple": { "message": "union" }},
  "array": [1, 2],
  "map": { "a": 1, "b": 2},
  "complexMap": { "x": { "message": "complexMap"}},
  "custom": 100
};

const wu: WithUnion = {
  "value": {
    "org.coursera.records.Message": {
      "title": "title",
      "body": "Hello, Courier."
    }
  }
};

const wctu_empty: WithComplexTypesUnion = {
  "union" : {
    "org.coursera.records.test.Empty" : { }
  }
};

const wctu_enum: WithComplexTypesUnion = {
  "union" : {
    "org.coursera.enums.Fruits" : "APPLE"
  }
};

const withCustomTypesArr: WithCustomTypesArray = {
  "ints" : [ 1, 2, 3 ],
  "arrays": [ [ { "message": "a1" } ] ],
  "maps": [ { "a": { "message": "m1" } } ],
  "unions": [
    { "int": 1 },
    { "string": "str" },
    { "org.coursera.records.test.Simple": { "message": "u1" }}
  ],
  "fixed": [ "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007" ]
};

const wctm: WithCustomTypesMap = {
  "ints" : {
    "b" : 2,
    "c" : 3,
    "a" : 1
  }
};

const wctm2: WithComplexTypesMap = {
  "empties" : {
    "b" : { },
    "c" : { },
    "a" : { }
  },
  "fruits" : {
    "b" : "BANANA",
    "c" : "ORANGE",
    "a" : "APPLE"
  },
  "arrays" : {
    "a": [ {"message": "v1"}, {"message": "v2"} ]
  },
  "maps": {
    "o1": {
      "i1": { "message": "o1i1" },
      "i2": { "message": "o1i2" }
    }
  },
  "unions": {
    "a": { "int": 1 },
    "b": { "string": "u1" }
  },
  "fixed": {
    "a": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007"
  }
};

const wdt: TestWithDateTime = {
  "createdAt": 1420070400000
};

const wp1: WithPrimitiveCustomTypes = {
  "intField" : 1
};

const wpu: WithPrimitiveCustomTypesUnion = {
  "union" : {
    "int" : 1
  }
};

const wp2: WithPrimitives = {
  "floatField" : 3.3,
  "doubleField" : 4.4,
  "intField" : 1,
  "bytesField" : "\u0000\u0001\u0002",
  "longField" : 2,
  "booleanField" : true,
  "stringField" : "str"
};

const wpa: WithPrimitivesArray = {
  "bytes" : [ "\u0000\u0001\u0002",
    "\u0003\u0004\u0005" ],
  "longs" : [ 10, 20, 30 ],
  "strings" : [ "a", "b", "c" ],
  "doubles" : [ 11.1, 22.2, 33.3 ],
  "booleans" : [ false, true ],
  "floats" : [ 1.1, 2.2, 3.3 ],
  "ints" : [ 1, 2, 3 ]
};

const wpm: WithPrimitivesMap = {
  "bytes" : {
    "b" : "\u0003\u0004\u0005",
    "c" : "\u0006\u0007\b",
    "a" : "\u0000\u0001\u0002"
  },
  "longs" : {
    "b" : 20,
    "c" : 30,
    "a" : 10
  },
  "strings" : {
    "b" : "string2",
    "c" : "string3",
    "a" : "string1"
  },
  "doubles" : {
    "b" : 22.2,
    "c" : 33.3,
    "a" : 11.1
  },
  "booleans" : {
    "b" : false,
    "c" : true,
    "a" : true
  },
  "floats" : {
    "b" : 2.2,
    "c" : 3.3,
    "a" : 1.1
  },
  "ints" : {
    "b" : 2,
    "c" : 3,
    "a" : 1
  }
};



const wtkm: WithTypedKeyMap = {
  "ints" : { "1": "int" },
  "longs" : { "2": "long" },
  "floats" : { "3.14": "float" },
  "doubles" : { "2.71": "double" },
  "booleans" : { "true": "boolean" },
  "strings" : { "key": "string" },
  "bytes" : { "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007": "bytes" },
  "record" : { "(message~key)": "record" },
  "array" : { "List(1,2)": "array" },
  "enum" : { "APPLE": "enum" },
  "custom" : { "100": "custom" },
  "fixed" : { "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007": "fixed" }
};

const wra: WithRecordArray = {
  "empties" : [ { }, { }, { } ],
  "fruits" : [ "APPLE", "BANANA", "ORANGE" ]
};

const wctu_array: WithComplexTypesUnion = {
  "union" : {
    "array" : [ { "message": "a1" } ] // TODO(eboto): Oops! Looks like it specified this in TS like arraySimple: union["Array<org.coursera.records.test.Simple>"]. It should have just been "array"
  }
};

const wctu_map: WithComplexTypesUnion = {
  "union" : {
    "map" : { "a": { "message": "m1" } }
  }
};


const wpu_long: WithPrimitivesUnion = {
  "union" : {
    "long" : 2
  }
};

const wpu_bool: WithPrimitivesUnion = {
  "union" : {
    "boolean" : true
  }
};

const wpu_string: WithPrimitivesUnion = {
  "union" : {
    "string" : "thestring"
  }
};

const wpu_bytes: WithPrimitivesUnion = {
  "union" : {
    "bytes" : "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007"
  }
};


const wpu_str: WithPrimitivesUnion = {
  "union" : {
    "string" : "str"
  }
};

const wpu_int: WithPrimitivesUnion = {
  "union" : {
    "int" : 1
  }
};

const wpu_float: WithPrimitivesUnion = {
  "union" : {
    "float" : 3.0
  }
};

const wpu_double: WithPrimitivesUnion = {
  "union" : {
    "double" : 4.0
  }
};




/* TODO(eboto): This one fails. Why? What is a TypedDefinition?
const wtd: WithTypedDefinition = {

  "value": {
    "typeName": "message",
    "definition": {
      "title": "title",
      "body": "Hello, Courier."
    }
  }
};
*/


/** TODO(eboto): Uncomment after support for flat type definitions
 const wftd: WithFlatTypedDefinition = {
  "value": {
    "typeName": "message",
    "title": "title",
    "body": "Hello, Courier."
  }
};
 */

/* TODO(eboto): This is not working because org.coursera.records.mutable.Simple doesn't exist. Ask jpbetz or saeta if this is actually meant to work.
 const withCustomTypesArrMutable: WithCustomTypesArray = {
 "ints" : [ 1, 2, 3 ],
 "arrays": [ [ { "message": "a1" } ] ],
 "maps": [ { "a": { "message": "m1" } } ],
 "unions": [
 { "number": 1 },
 { "string": "str" },
 { "org.coursera.records.mutable.Simple": { "message": "u1" }}
 ],
 "fixed": [ "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007" ]
 }
 */
