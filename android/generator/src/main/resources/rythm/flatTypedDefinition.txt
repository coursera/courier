@args com.linkedin.pegasus.generator.spec.UnionTemplateSpec union, java.util.Map<String, String> memberKeyToTypeName, org.coursera.courier.android.JavaSyntax syntax, boolean mutable
@import com.linkedin.pegasus.generator.spec.RecordTemplateSpec
@import com.linkedin.pegasus.generator.spec.RecordTemplateSpec.Field
@import com.linkedin.pegasus.generator.spec.UnionTemplateSpec.Member
@import org.coursera.courier.android.JavaSyntax
@import com.linkedin.data.schema.DataSchema.Type

@maybePackageAndImports(union)

@{ String className = syntax.escapeKeyword(union.getClassName()) }

@if (union.getTyperefClass() != null) {
  @classAnnotations(union.getTyperefClass().getSchema())
}
@@JsonAdapter(@(className).Adapter.class)
public interface @className {
  @for(Member member: union.getMembers()) {
    @{ String memberKey = member.getClassTemplateSpec().getSchema().getUnionMemberKey() }
    @{ String unionMemberName = syntax.toUnionMemberName(member.getClassTemplateSpec()) }
    @if (member.getClassTemplateSpec().getSchema().getType() != Type.RECORD) {
      // flatTypedDefinition members must all be records, but found: @memberKey
    } else {
      public @if (union.getEnclosingClass() != null) {static} class @unionMemberName implements @className {
        @{List<Field> fields = ((RecordTemplateSpec)member.getClassTemplateSpec()).getFields() }

        @if(!mutable) {
          public @(unionMemberName)(@syntax.fieldAndTypeList(fields)) {
            @for(Field field: fields) {
              @{ String fieldName = syntax.escapeKeyword(field.getSchemaField().getName()) }
              this.@fieldName = @fieldName;
            }
          }
        }

        private static final String TYPE_NAME = "@memberKeyToTypeName.get(memberKey)";

        public final String typeName = TYPE_NAME;

        @for(Field field: fields) {
          @if(field.getCustomInfo() != null) {
            @@JsonAdapter(@(syntax.toType(field.getCustomInfo().getCoercerClass())).class)
          }
          @fieldAnnotations(field)
          @if(!syntax.escapeKeyword(field.getSchemaField().getName()).equals(field.getSchemaField().getName())) { @@SerializedName("@field.getSchemaField().getName()") }
          public @if(!mutable){final} @syntax.toType(field.getType()) @syntax.escapeKeyword(field.getSchemaField().getName());
        }

        @if(!mutable) {
          @@Override
          public int hashCode() {
            @if(fields.size() == 0) {
              return Objects.hashCode(this.getClass());
            } else {
              return Objects.hash(this.getClass(), @syntax.fieldList(fields));
            }
          }

          @@Override
          public boolean equals(Object obj) {
            if (!(obj instanceof @unionMemberName)) return false;
            @unionMemberName other = (@unionMemberName)obj;
            if (other == this) return true;
            return @for(Field field: fields) {Objects.deepEquals(this.@syntax.escapeKeyword(field.getSchemaField().getName()), other.@syntax.escapeKeyword(field.getSchemaField().getName())) &&} true;
          }
        }
      }
    }
  }

  public final class $UnknownMember implements @className {
    private $UnknownMember() { }
  }

  final class Adapter extends TypedDefinitionAdapterFactory<@className> {
    Adapter() {
      super(@(className).class, new TypedDefinitionAdapterFactory.Resolver<@className>() {
        @@Override
        public Class<? extends @className> resolve(String typeName) {
          switch (typeName) {
            @for(Member member: union.getMembers()) {
              @{ String unionMemberName = syntax.toUnionMemberName(member.getClassTemplateSpec()) } case @(unionMemberName).TYPE_NAME: return @(unionMemberName).class;
            }
            default: return $UnknownMember.class;
          }
        }
      });
    }
  }
}
